import { createAsyncThunk, createSelector, createSlice } from '@reduxjs/toolkit';
import axios from 'axios';
import { RootState } from '../store/store';
import { Transaction } from '../types/Transaction';

export interface TransactionState {
	transactions: Transaction[];
	error: string | null;
	loading: boolean;
}

const initialState: TransactionState = {
	transactions: [],
	error: null,
	loading: true,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(getTransactionsAsync())`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getTransactionsAsync = createAsyncThunk('transactions/getTransactions', async (_, { rejectWithValue }) => {
	try {
		const response = await axios.get('/api/v1/transactions');
		// The value we return becomes the `fulfilled` action payload
		return response.data;
	} catch (error: any) {
		// Use `error.response.data` as `action.payload` for a `rejected` action,
		// by explicitly returning it using the `rejectWithValue()` utility
		return rejectWithValue(error.response.data.message);
	}
});

export const addTransactionAsync = createAsyncThunk(
	'transactions/addTransaction',
	async (transaction: Omit<Transaction, 'id'>, { rejectWithValue }) => {
		const config = {
			headers: {
				'Content-Type': 'application/json',
			},
		};
		try {
			const response = await axios.post('/api/v1/transactions', transaction, config);
			return response.data.data;
		} catch (error: any) {
			return rejectWithValue(error.response.data.message);
		}
	},
);

export const deleteTransactionAsync = createAsyncThunk(
	'transactions/deleteTransaction',
	async (id: number, { rejectWithValue }) => {
		try {
			await axios.delete(`/api/v1/transactions/${id}`);
			return id;
		} catch (error: any) {
			return rejectWithValue(error.response.data.message);
		}
	},
);

export const transactionsSlice = createSlice({
	name: 'transactions',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(getTransactionsAsync.pending, (state) => {
				state.loading = true;
			})
			.addCase(getTransactionsAsync.fulfilled, (state, action) => {
				state.loading = false;
				state.error = null;
				state.transactions = action.payload.data;
			})
			.addCase(getTransactionsAsync.rejected, (state, action) => {
				state.loading = false;
				state.error = action.payload as string;
			})
			.addCase(addTransactionAsync.fulfilled, (state, action) => {
				state.error = null;
				state.transactions.push(action.payload);
			})
			.addCase(addTransactionAsync.rejected, (state, action) => {
				state.error = action.payload as string;
			})
			.addCase(deleteTransactionAsync.fulfilled, (state, action) => {
				state.error = null;
				state.transactions = state.transactions.filter((transaction) => transaction.id !== action.payload);
			})
			.addCase(deleteTransactionAsync.rejected, (state, action) => {
				state.error = action.payload as string;
			});
	},
});

// Export selectors:
export const selectTransactions = (state: RootState) => state.transactions.transactions;

export const selectTotalAmount = createSelector(selectTransactions, (transactions) =>
	transactions.reduce((acc, item) => (acc += item.amount), 0).toFixed(2),
);

export const selectTotalIncome = createSelector(selectTransactions, (transactions) =>
	transactions
		.filter((item) => item.amount > 0)
		.reduce((acc, item) => (acc += item.amount), 0)
		.toFixed(2),
);

export const selectTotalExpense = createSelector(selectTransactions, (transactions) =>
	(transactions.filter((item) => item.amount < 0).reduce((acc, item) => (acc += item.amount), 0) * -1).toFixed(2),
);

export default transactionsSlice.reducer;
